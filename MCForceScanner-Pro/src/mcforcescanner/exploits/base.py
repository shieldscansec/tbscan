"""
Base para Exploits do MCForceScanner-Pro

Este módulo define a interface base para todos os exploits,
fornecendo estrutura comum e funcionalidades compartilhadas.
"""

import asyncio
import time
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, field
from enum import Enum

from ..core.exceptions import ExploitError, ExploitExecutionError
from ..core.config import get_config
from ..network.scanner import MinecraftServer

logger = logging.getLogger(__name__)


class ExploitSeverity(Enum):
    """Níveis de severidade de exploits."""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class ExploitCategory(Enum):
    """Categorias de exploits."""
    INFORMATION = "information"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INJECTION = "injection"
    DENIAL_OF_SERVICE = "denial_of_service"
    REMOTE_CODE_EXECUTION = "remote_code_execution"
    PRIVILEGE_ESCALATION = "privilege_escalation"


@dataclass
class ExploitTarget:
    """Representa um target para exploit."""
    host: str
    port: int
    server_info: Optional[MinecraftServer] = None
    additional_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitResult:
    """Resultado da execução de um exploit."""
    exploit_name: str
    target: ExploitTarget
    success: bool
    severity: ExploitSeverity
    category: ExploitCategory
    result_data: Dict[str, Any] = field(default_factory=dict)
    error_message: Optional[str] = None
    execution_time: float = 0.0
    timestamp: float = field(default_factory=time.time)
    
    def to_dict(self) -> Dict[str, Any]:
        """Converte o resultado para dicionário."""
        return {
            "exploit_name": self.exploit_name,
            "target": {
                "host": self.target.host,
                "port": self.target.port,
                "server_info": self.target.server_info.__dict__ if self.target.server_info else None,
                "additional_data": self.target.additional_data
            },
            "success": self.success,
            "severity": self.severity.value,
            "category": self.category.value,
            "result_data": self.result_data,
            "error_message": self.error_message,
            "execution_time": self.execution_time,
            "timestamp": self.timestamp
        }


class BaseExploit(ABC):
    """
    Classe base para todos os exploits.
    
    Todos os exploits devem herdar desta classe e implementar
    os métodos abstratos necessários.
    """
    
    # Metadados do exploit (devem ser definidos nas subclasses)
    name: str = ""
    description: str = ""
    author: str = ""
    version: str = "1.0.0"
    severity: ExploitSeverity = ExploitSeverity.LOW
    category: ExploitCategory = ExploitCategory.INFORMATION
    
    # Configurações do exploit
    requires_auth: bool = False
    requires_rcon: bool = False
    requires_query: bool = False
    supports_offline: bool = True
    
    # Versões do Minecraft suportadas
    supported_versions: List[str] = []
    
    def __init__(self):
        """Inicializa o exploit."""
        self.config = get_config()
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self._validate_metadata()
    
    def _validate_metadata(self) -> None:
        """Valida os metadados do exploit."""
        required_fields = ["name", "description", "author"]
        for field in required_fields:
            if not getattr(self, field):
                raise ExploitError(f"Campo obrigatório '{field}' não definido no exploit {self.__class__.__name__}")
    
    @abstractmethod
    async def execute(self, target: ExploitTarget) -> ExploitResult:
        """
        Executa o exploit contra um target.
        
        Args:
            target: Target para executar o exploit
            
        Returns:
            Resultado da execução
        """
        pass
    
    async def check_prerequisites(self, target: ExploitTarget) -> bool:
        """
        Verifica se os pré-requisitos para o exploit são atendidos.
        
        Args:
            target: Target para verificar
            
        Returns:
            True se os pré-requisitos são atendidos
        """
        # Verifica se o servidor está online
        if not self.supports_offline and not target.server_info:
            return False
        
        # Verifica versão do Minecraft se especificada
        if self.supported_versions and target.server_info:
            server_version = target.server_info.version
            if server_version and not any(v in server_version for v in self.supported_versions):
                return False
        
        # Verifica requisitos específicos
        if self.requires_auth:
            # Verificar se há credenciais de autenticação
            pass
        
        if self.requires_rcon:
            # Verificar se RCON está disponível
            pass
        
        if self.requires_query:
            # Verificar se Query está disponível
            pass
        
        return True
    
    async def run(self, target: ExploitTarget) -> ExploitResult:
        """
        Executa o exploit com tratamento de erros e medição de tempo.
        
        Args:
            target: Target para executar o exploit
            
        Returns:
            Resultado da execução
        """
        start_time = time.time()
        
        try:
            self.logger.info(f"Iniciando exploit {self.name} contra {target.host}:{target.port}")
            
            # Verifica pré-requisitos
            if not await self.check_prerequisites(target):
                return ExploitResult(
                    exploit_name=self.name,
                    target=target,
                    success=False,
                    severity=self.severity,
                    category=self.category,
                    error_message="Pré-requisitos não atendidos",
                    execution_time=time.time() - start_time
                )
            
            # Executa o exploit
            result = await self.execute(target)
            result.execution_time = time.time() - start_time
            
            if result.success:
                self.logger.info(f"Exploit {self.name} executado com sucesso")
            else:
                self.logger.warning(f"Exploit {self.name} falhou: {result.error_message}")
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            error_msg = f"Erro durante execução do exploit: {str(e)}"
            self.logger.error(error_msg)
            
            return ExploitResult(
                exploit_name=self.name,
                target=target,
                success=False,
                severity=self.severity,
                category=self.category,
                error_message=error_msg,
                execution_time=execution_time
            )
    
    def get_metadata(self) -> Dict[str, Any]:
        """
        Retorna metadados do exploit.
        
        Returns:
            Dicionário com metadados
        """
        return {
            "name": self.name,
            "description": self.description,
            "author": self.author,
            "version": self.version,
            "severity": self.severity.value,
            "category": self.category.value,
            "requires_auth": self.requires_auth,
            "requires_rcon": self.requires_rcon,
            "requires_query": self.requires_query,
            "supports_offline": self.supports_offline,
            "supported_versions": self.supported_versions
        }
    
    async def connect_to_server(self, host: str, port: int, timeout: Optional[float] = None) -> tuple:
        """
        Conecta ao servidor Minecraft.
        
        Args:
            host: Endereço do servidor
            port: Porta do servidor
            timeout: Timeout da conexão
            
        Returns:
            Tupla (reader, writer) da conexão
        """
        if timeout is None:
            timeout = self.config.scanner.timeout
        
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )
            return reader, writer
        except Exception as e:
            raise ExploitExecutionError(f"Falha ao conectar com {host}:{port}: {str(e)}")
    
    async def send_packet(self, writer, packet_data: bytes) -> None:
        """
        Envia um pacote para o servidor.
        
        Args:
            writer: Writer da conexão
            packet_data: Dados do pacote
        """
        try:
            writer.write(packet_data)
            await writer.drain()
        except Exception as e:
            raise ExploitExecutionError(f"Falha ao enviar pacote: {str(e)}")
    
    async def receive_packet(self, reader, max_size: int = 4096) -> bytes:
        """
        Recebe um pacote do servidor.
        
        Args:
            reader: Reader da conexão
            max_size: Tamanho máximo do pacote
            
        Returns:
            Dados do pacote recebido
        """
        try:
            data = await reader.read(max_size)
            if not data:
                raise ExploitExecutionError("Conexão fechada pelo servidor")
            return data
        except Exception as e:
            raise ExploitExecutionError(f"Falha ao receber pacote: {str(e)}")
    
    async def close_connection(self, writer) -> None:
        """
        Fecha a conexão com o servidor.
        
        Args:
            writer: Writer da conexão
        """
        try:
            writer.close()
            await writer.wait_closed()
        except Exception:
            pass  # Ignora erros ao fechar conexão
    
    def create_result(
        self,
        target: ExploitTarget,
        success: bool,
        result_data: Optional[Dict[str, Any]] = None,
        error_message: Optional[str] = None
    ) -> ExploitResult:
        """
        Cria um resultado de exploit.
        
        Args:
            target: Target do exploit
            success: Se o exploit foi bem-sucedido
            result_data: Dados do resultado
            error_message: Mensagem de erro (se houver)
            
        Returns:
            Resultado do exploit
        """
        return ExploitResult(
            exploit_name=self.name,
            target=target,
            success=success,
            severity=self.severity,
            category=self.category,
            result_data=result_data or {},
            error_message=error_message
        )


class InformationExploit(BaseExploit):
    """Classe base para exploits de coleta de informações."""
    
    category = ExploitCategory.INFORMATION
    severity = ExploitSeverity.LOW


class AuthenticationExploit(BaseExploit):
    """Classe base para exploits de autenticação."""
    
    category = ExploitCategory.AUTHENTICATION
    severity = ExploitSeverity.MEDIUM


class AuthorizationExploit(BaseExploit):
    """Classe base para exploits de autorização."""
    
    category = ExploitCategory.AUTHORIZATION
    severity = ExploitSeverity.HIGH


class InjectionExploit(BaseExploit):
    """Classe base para exploits de injeção."""
    
    category = ExploitCategory.INJECTION
    severity = ExploitSeverity.HIGH


class DoSExploit(BaseExploit):
    """Classe base para exploits de negação de serviço."""
    
    category = ExploitCategory.DENIAL_OF_SERVICE
    severity = ExploitSeverity.HIGH


class RCEExploit(BaseExploit):
    """Classe base para exploits de execução remota de código."""
    
    category = ExploitCategory.REMOTE_CODE_EXECUTION
    severity = ExploitSeverity.CRITICAL


class PrivilegeEscalationExploit(BaseExploit):
    """Classe base para exploits de escalação de privilégios."""
    
    category = ExploitCategory.PRIVILEGE_ESCALATION
    severity = ExploitSeverity.CRITICAL


def exploit_metadata(
    name: str,
    description: str,
    author: str,
    version: str = "1.0.0",
    severity: ExploitSeverity = ExploitSeverity.LOW,
    category: ExploitCategory = ExploitCategory.INFORMATION,
    requires_auth: bool = False,
    requires_rcon: bool = False,
    requires_query: bool = False,
    supports_offline: bool = True,
    supported_versions: Optional[List[str]] = None
):
    """
    Decorator para definir metadados de exploits.
    
    Args:
        name: Nome do exploit
        description: Descrição do exploit
        author: Autor do exploit
        version: Versão do exploit
        severity: Severidade do exploit
        category: Categoria do exploit
        requires_auth: Se requer autenticação
        requires_rcon: Se requer RCON
        requires_query: Se requer Query
        supports_offline: Se suporta servidores offline
        supported_versions: Versões do Minecraft suportadas
    """
    def decorator(cls):
        cls.name = name
        cls.description = description
        cls.author = author
        cls.version = version
        cls.severity = severity
        cls.category = category
        cls.requires_auth = requires_auth
        cls.requires_rcon = requires_rcon
        cls.requires_query = requires_query
        cls.supports_offline = supports_offline
        cls.supported_versions = supported_versions or []
        return cls
    return decorator