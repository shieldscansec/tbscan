"""
Gerenciador de Exploits para MCForceScanner-Pro

Este módulo gerencia o carregamento, registro e execução de exploits,
incluindo carregamento dinâmico de plugins e execução paralela.
"""

import asyncio
import importlib
import inspect
import pkgutil
from pathlib import Path
from typing import Dict, List, Optional, Type, Any, Union
import logging

from .base import BaseExploit, ExploitTarget, ExploitResult, ExploitSeverity, ExploitCategory
from ..core.exceptions import ExploitError, ExploitNotFoundError, PluginLoadError
from ..core.config import get_config
from ..network.scanner import MinecraftServer

logger = logging.getLogger(__name__)


class ExploitManager:
    """Gerenciador central de exploits."""
    
    def __init__(self):
        """Inicializa o gerenciador de exploits."""
        self.config = get_config()
        self._exploits: Dict[str, Type[BaseExploit]] = {}
        self._loaded_modules: List[str] = []
        self._load_builtin_exploits()
        self._load_plugin_exploits()
    
    def _load_builtin_exploits(self) -> None:
        """Carrega exploits built-in do sistema."""
        try:
            # Importa exploits de informação
            from .information.version_scan import VersionScanExploit
            
            # Registra exploits
            self.register_exploit(VersionScanExploit)
            
            logger.info(f"Carregados {len(self._exploits)} exploits built-in")
            
        except Exception as e:
            logger.error(f"Erro ao carregar exploits built-in: {str(e)}")
    
    def _load_plugin_exploits(self) -> None:
        """Carrega exploits de plugins externos."""
        if not self.config.plugins.auto_load:
            return
        
        for plugin_dir in self.config.plugins.directories:
            plugin_path = Path(plugin_dir)
            if not plugin_path.exists():
                continue
            
            try:
                self._load_exploits_from_directory(plugin_path)
            except Exception as e:
                logger.error(f"Erro ao carregar exploits de {plugin_dir}: {str(e)}")
    
    def _load_exploits_from_directory(self, directory: Path) -> None:
        """
        Carrega exploits de um diretório específico.
        
        Args:
            directory: Diretório para carregar exploits
        """
        for file_path in directory.rglob("*.py"):
            if file_path.name.startswith("_"):
                continue
            
            try:
                self._load_exploit_from_file(file_path)
            except Exception as e:
                logger.warning(f"Erro ao carregar exploit de {file_path}: {str(e)}")
    
    def _load_exploit_from_file(self, file_path: Path) -> None:
        """
        Carrega um exploit de um arquivo específico.
        
        Args:
            file_path: Caminho para o arquivo do exploit
        """
        # Cria nome do módulo baseado no caminho
        module_name = f"exploit_{file_path.stem}_{hash(str(file_path))}"
        
        # Carrega o módulo dinamicamente
        spec = importlib.util.spec_from_file_location(module_name, file_path)
        if not spec or not spec.loader:
            raise PluginLoadError(f"Não foi possível carregar especificação do módulo: {file_path}")
        
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        # Procura por classes de exploit no módulo
        for name, obj in inspect.getmembers(module, inspect.isclass):
            if (issubclass(obj, BaseExploit) and 
                obj != BaseExploit and 
                hasattr(obj, 'name') and 
                obj.name):
                
                self.register_exploit(obj)
                logger.info(f"Exploit carregado: {obj.name} de {file_path}")
    
    def register_exploit(self, exploit_class: Type[BaseExploit]) -> None:
        """
        Registra uma classe de exploit.
        
        Args:
            exploit_class: Classe do exploit para registrar
        """
        if not issubclass(exploit_class, BaseExploit):
            raise ExploitError(f"Classe {exploit_class.__name__} não é um exploit válido")
        
        # Cria instância temporária para validar metadados
        try:
            temp_instance = exploit_class()
            exploit_name = temp_instance.name
            
            if not exploit_name:
                raise ExploitError(f"Exploit {exploit_class.__name__} não tem nome definido")
            
            self._exploits[exploit_name] = exploit_class
            logger.debug(f"Exploit registrado: {exploit_name}")
            
        except Exception as e:
            raise ExploitError(f"Erro ao registrar exploit {exploit_class.__name__}: {str(e)}")
    
    def get_exploit(self, name: str) -> Type[BaseExploit]:
        """
        Obtém uma classe de exploit pelo nome.
        
        Args:
            name: Nome do exploit
            
        Returns:
            Classe do exploit
        """
        if name not in self._exploits:
            raise ExploitNotFoundError(f"Exploit '{name}' não encontrado")
        
        return self._exploits[name]
    
    def list_exploits(self) -> List[Dict[str, Any]]:
        """
        Lista todos os exploits disponíveis.
        
        Returns:
            Lista de metadados dos exploits
        """
        exploits_info = []
        
        for name, exploit_class in self._exploits.items():
            try:
                instance = exploit_class()
                exploits_info.append(instance.get_metadata())
            except Exception as e:
                logger.warning(f"Erro ao obter metadados do exploit {name}: {str(e)}")
        
        return exploits_info
    
    def list_exploits_by_category(self, category: ExploitCategory) -> List[str]:
        """
        Lista exploits por categoria.
        
        Args:
            category: Categoria dos exploits
            
        Returns:
            Lista de nomes de exploits
        """
        matching_exploits = []
        
        for name, exploit_class in self._exploits.items():
            try:
                instance = exploit_class()
                if instance.category == category:
                    matching_exploits.append(name)
            except Exception:
                continue
        
        return matching_exploits
    
    def list_exploits_by_severity(self, severity: ExploitSeverity) -> List[str]:
        """
        Lista exploits por severidade.
        
        Args:
            severity: Severidade dos exploits
            
        Returns:
            Lista de nomes de exploits
        """
        matching_exploits = []
        
        for name, exploit_class in self._exploits.items():
            try:
                instance = exploit_class()
                if instance.severity == severity:
                    matching_exploits.append(name)
            except Exception:
                continue
        
        return matching_exploits
    
    async def execute_exploit(self, exploit_name: str, target: ExploitTarget) -> ExploitResult:
        """
        Executa um exploit específico.
        
        Args:
            exploit_name: Nome do exploit
            target: Target para executar
            
        Returns:
            Resultado da execução
        """
        exploit_class = self.get_exploit(exploit_name)
        exploit_instance = exploit_class()
        
        return await exploit_instance.run(target)
    
    async def execute_multiple_exploits(
        self, 
        exploit_names: List[str], 
        target: ExploitTarget,
        parallel: bool = True
    ) -> Dict[str, ExploitResult]:
        """
        Executa múltiplos exploits.
        
        Args:
            exploit_names: Lista de nomes de exploits
            target: Target para executar
            parallel: Se deve executar em paralelo
            
        Returns:
            Dicionário com resultados por exploit
        """
        results = {}
        
        if parallel:
            # Execução paralela
            tasks = []
            for exploit_name in exploit_names:
                task = self.execute_exploit(exploit_name, target)
                tasks.append((exploit_name, task))
            
            completed_tasks = await asyncio.gather(
                *[task for _, task in tasks], 
                return_exceptions=True
            )
            
            for (exploit_name, _), result in zip(tasks, completed_tasks):
                if isinstance(result, Exception):
                    # Cria resultado de erro
                    results[exploit_name] = ExploitResult(
                        exploit_name=exploit_name,
                        target=target,
                        success=False,
                        severity=ExploitSeverity.LOW,
                        category=ExploitCategory.INFORMATION,
                        error_message=str(result)
                    )
                else:
                    results[exploit_name] = result
        else:
            # Execução sequencial
            for exploit_name in exploit_names:
                try:
                    result = await self.execute_exploit(exploit_name, target)
                    results[exploit_name] = result
                except Exception as e:
                    results[exploit_name] = ExploitResult(
                        exploit_name=exploit_name,
                        target=target,
                        success=False,
                        severity=ExploitSeverity.LOW,
                        category=ExploitCategory.INFORMATION,
                        error_message=str(e)
                    )
        
        return results
    
    async def execute_enabled_exploits(self, target: ExploitTarget) -> Dict[str, ExploitResult]:
        """
        Executa todos os exploits habilitados na configuração.
        
        Args:
            target: Target para executar
            
        Returns:
            Dicionário com resultados por exploit
        """
        enabled_exploits = self.config.exploits.enabled
        return await self.execute_multiple_exploits(enabled_exploits, target)
    
    async def scan_server(self, server: MinecraftServer) -> Dict[str, ExploitResult]:
        """
        Executa scan completo em um servidor.
        
        Args:
            server: Servidor para escanear
            
        Returns:
            Dicionário com resultados por exploit
        """
        target = ExploitTarget(
            host=server.host,
            port=server.port,
            server_info=server
        )
        
        return await self.execute_enabled_exploits(target)
    
    async def scan_multiple_servers(
        self, 
        servers: List[MinecraftServer],
        max_concurrent: Optional[int] = None
    ) -> Dict[str, Dict[str, ExploitResult]]:
        """
        Executa scan em múltiplos servidores.
        
        Args:
            servers: Lista de servidores
            max_concurrent: Máximo de scans concorrentes
            
        Returns:
            Dicionário aninhado com resultados por servidor e exploit
        """
        if max_concurrent is None:
            max_concurrent = self.config.scanner.threads
        
        semaphore = asyncio.Semaphore(max_concurrent)
        results = {}
        
        async def scan_single_server(server: MinecraftServer) -> None:
            async with semaphore:
                server_key = f"{server.host}:{server.port}"
                try:
                    server_results = await self.scan_server(server)
                    results[server_key] = server_results
                except Exception as e:
                    logger.error(f"Erro ao escanear servidor {server_key}: {str(e)}")
                    results[server_key] = {}
        
        tasks = [scan_single_server(server) for server in servers]
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return results
    
    def filter_exploits(
        self,
        category: Optional[ExploitCategory] = None,
        severity: Optional[ExploitSeverity] = None,
        requires_auth: Optional[bool] = None,
        requires_rcon: Optional[bool] = None,
        requires_query: Optional[bool] = None,
        supports_offline: Optional[bool] = None
    ) -> List[str]:
        """
        Filtra exploits baseado em critérios.
        
        Args:
            category: Categoria do exploit
            severity: Severidade do exploit
            requires_auth: Se requer autenticação
            requires_rcon: Se requer RCON
            requires_query: Se requer Query
            supports_offline: Se suporta servidores offline
            
        Returns:
            Lista de nomes de exploits que atendem aos critérios
        """
        matching_exploits = []
        
        for name, exploit_class in self._exploits.items():
            try:
                instance = exploit_class()
                
                # Aplica filtros
                if category is not None and instance.category != category:
                    continue
                
                if severity is not None and instance.severity != severity:
                    continue
                
                if requires_auth is not None and instance.requires_auth != requires_auth:
                    continue
                
                if requires_rcon is not None and instance.requires_rcon != requires_rcon:
                    continue
                
                if requires_query is not None and instance.requires_query != requires_query:
                    continue
                
                if supports_offline is not None and instance.supports_offline != supports_offline:
                    continue
                
                matching_exploits.append(name)
                
            except Exception:
                continue
        
        return matching_exploits
    
    def reload_exploits(self) -> None:
        """Recarrega todos os exploits."""
        logger.info("Recarregando exploits...")
        
        # Limpa exploits atuais
        self._exploits.clear()
        self._loaded_modules.clear()
        
        # Recarrega exploits
        self._load_builtin_exploits()
        self._load_plugin_exploits()
        
        logger.info(f"Recarregados {len(self._exploits)} exploits")
    
    def get_exploit_stats(self) -> Dict[str, Any]:
        """
        Obtém estatísticas dos exploits carregados.
        
        Returns:
            Dicionário com estatísticas
        """
        stats = {
            "total_exploits": len(self._exploits),
            "by_category": {},
            "by_severity": {},
            "requires_auth": 0,
            "requires_rcon": 0,
            "requires_query": 0,
            "supports_offline": 0
        }
        
        for exploit_class in self._exploits.values():
            try:
                instance = exploit_class()
                
                # Conta por categoria
                category = instance.category.value
                stats["by_category"][category] = stats["by_category"].get(category, 0) + 1
                
                # Conta por severidade
                severity = instance.severity.value
                stats["by_severity"][severity] = stats["by_severity"].get(severity, 0) + 1
                
                # Conta requisitos
                if instance.requires_auth:
                    stats["requires_auth"] += 1
                if instance.requires_rcon:
                    stats["requires_rcon"] += 1
                if instance.requires_query:
                    stats["requires_query"] += 1
                if instance.supports_offline:
                    stats["supports_offline"] += 1
                    
            except Exception:
                continue
        
        return stats


# Instância global do gerenciador
_exploit_manager: Optional[ExploitManager] = None


def get_exploit_manager() -> ExploitManager:
    """
    Obtém a instância global do gerenciador de exploits.
    
    Returns:
        Instância do ExploitManager
    """
    global _exploit_manager
    
    if _exploit_manager is None:
        _exploit_manager = ExploitManager()
    
    return _exploit_manager