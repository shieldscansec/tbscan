"""
Version Scanner Exploit

Exploit para obter informações de versão e status de servidores Minecraft.
"""

import json
import struct
from typing import Dict, Any

from ..base import InformationExploit, ExploitTarget, ExploitResult, exploit_metadata
from ...network.scanner import MinecraftProtocol


@exploit_metadata(
    name="version_scan",
    description="Obtém informações de versão e status do servidor Minecraft",
    author="MCForceScanner Team",
    version="1.0.0"
)
class VersionScanExploit(InformationExploit):
    """Exploit para escanear versão de servidores Minecraft."""
    
    async def execute(self, target: ExploitTarget) -> ExploitResult:
        """
        Executa o scan de versão.
        
        Args:
            target: Target para escanear
            
        Returns:
            Resultado do exploit
        """
        try:
            # Conecta ao servidor
            reader, writer = await self.connect_to_server(target.host, target.port)
            
            try:
                # Envia handshake
                handshake = MinecraftProtocol.create_handshake_packet(target.host, target.port)
                await self.send_packet(writer, handshake)
                
                # Envia requisição de status
                status_request = MinecraftProtocol.create_status_request()
                await self.send_packet(writer, status_request)
                
                # Recebe resposta
                response_data = await self.receive_packet(reader, 8192)
                
                # Parse da resposta
                response_length, varint_size = MinecraftProtocol.unpack_varint(response_data)
                packet_data = response_data[varint_size:varint_size + response_length]
                
                packet_id, offset = MinecraftProtocol.unpack_varint(packet_data)
                if packet_id != 0x00:  # Status Response packet ID
                    return self.create_result(
                        target, False, 
                        error_message="Resposta inválida do servidor"
                    )
                
                json_string, _ = MinecraftProtocol.unpack_string(packet_data, offset)
                server_data = json.loads(json_string)
                
                # Extrai informações
                result_data = {
                    "raw_response": server_data,
                    "version": {},
                    "players": {},
                    "description": "",
                    "favicon": None,
                    "mods": []
                }
                
                # Informações de versão
                if "version" in server_data:
                    result_data["version"] = {
                        "name": server_data["version"].get("name"),
                        "protocol": server_data["version"].get("protocol")
                    }
                
                # Informações de players
                if "players" in server_data:
                    result_data["players"] = {
                        "online": server_data["players"].get("online", 0),
                        "max": server_data["players"].get("max", 0),
                        "sample": server_data["players"].get("sample", [])
                    }
                
                # Descrição (MOTD)
                if "description" in server_data:
                    desc = server_data["description"]
                    if isinstance(desc, dict):
                        result_data["description"] = desc.get("text", "")
                    else:
                        result_data["description"] = str(desc)
                
                # Favicon
                result_data["favicon"] = server_data.get("favicon")
                
                # Informações de mods (Forge/Fabric)
                if "modinfo" in server_data:
                    result_data["mods"] = server_data["modinfo"].get("modList", [])
                    result_data["forge_data"] = server_data["modinfo"]
                
                return self.create_result(target, True, result_data)
                
            finally:
                await self.close_connection(writer)
                
        except Exception as e:
            return self.create_result(
                target, False,
                error_message=f"Erro durante scan de versão: {str(e)}"
            )